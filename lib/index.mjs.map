{"mappings":"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","sources":["src/index.ts","src/hnsw.ts","src/utils/index.ts","node_modules/.pnpm/@parcel+transformer-js@2.10.3_@parcel+core@2.10.3/node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/db/hollowdb.ts","src/proto/index.ts","proto/hnsw_comm.js","src/db/common/index.ts"],"sourcesContent":["import { ContractState, SetSDK } from \"hollowdb\";\nimport { HNSW } from \"./hnsw\";\nimport { HollowMemory } from \"./db/hollowdb\";\nimport type { JWKInterface, Warp } from \"warp-contracts\";\nimport { ArweaveSigner } from \"warp-contracts-plugin-deploy\";\n\n/**\n * Backwards compatibility with [Dria](https://dria.co/) contracts that make use\n * of a custom contract function called `upsertVectorMulti`, which is actually\n * equivalent to `setMany`.\n *\n * This class overrides the `set` and `setMany` functions of `SetSDK<string>` from HollowDB.\n */\nexport class DriaCompatSDK extends SetSDK<string> {\n  override async setMany(keys: string[], values: string[]): Promise<void> {\n    await this.base.dryWriteInteraction({\n      function: \"upsertVectorMulti\",\n      value: {\n        keys,\n        values,\n      },\n    });\n  }\n\n  override async set(key: string, value: string): Promise<void> {\n    await this.setMany([key], [value]);\n  }\n}\n\nexport default class HollowDBVector<M = unknown> extends HNSW<M> {\n  /** HollowDB SDK instance as passed in the `constructor`. */\n  sdk: SetSDK<string>;\n\n  /**\n   * A VectorDB over HollowDB using HNSW index.\n   *\n   * @param hollowdb a hollowdb instance with `set` and `setMany` operations, where values are `string` typed.\n   * - Vectors are encoded & decoded with protobuffers, and the base64 of encodings are stored in HollowDB\n   * - Metadatas are stored as JSON-stringified values.\n   * - Some of the HollowDB contracts (especially those in [Dria](https://dria.co/)) may use a function called\n   * `upsertVectorMulti`, which is incompatible with `SetSDK`. For these, you may use `DriaCompatSDK`.\n   *\n   * @param options Optional HNSW parameters:\n   *\n   * - `m`:  **Number of established connections.**\n   * With higher dimension size, this should also be larger.\n   * Defaults to 5.\n   *\n   * - `efConstruction`: **Size of the dynamic candidate list.**\n   * Affects build times, for instance: 400 is slow but powerful, 40 is\n   * fast but not that performant.\n   * Defaults to 128.\n   *\n   * - `efSearch`: **Factor for quality of search.** Defaults to 20.\n   *\n   * @template M type of the metadata\n   */\n  constructor(\n    hollowdb: SetSDK<string>,\n    options?: {\n      m?: number;\n      efConstruction?: number;\n      efSearch?: number;\n    },\n  ) {\n    const m = options?.m || 5;\n    const ef_construction = options?.efConstruction || 128;\n    const ef_search = options?.efSearch || 20;\n\n    super(new HollowMemory<M>(hollowdb), m, ef_construction, ef_search);\n\n    this.sdk = hollowdb;\n  }\n\n  /** Deploy a new HollowDB Vector contract,\n   * which is a HollowDB contract with `set` and `setMany` functions in particular.\n   *\n   * @param wallet your Arweave wallet\n   * @param warp a Warp instance on mainnet\n   * @returns deployed contract transaction id and source transaction id\n   */\n  static async deploy(wallet: JWKInterface, warp: Warp): Promise<{ contractTxId: string; srcTxId: string }> {\n    // source transaction id, for the contract to be deployed\n    const srcTxId = \"lSRrPRiiMYeJsGgT9BdV9OTZTw3hZw_UkGVpEXjD5sY\";\n\n    // our source txid is on mainnet, so we must make sure of that\n    if (warp.environment !== \"mainnet\") {\n      throw new Error(\"Warp must be connected to mainnet.\");\n    }\n\n    // initailly the wallet is whitelisted on everything, and all\n    // whitelists are required for the contract\n    const addr = await warp.arweave.wallets.jwkToAddress(wallet);\n    const initialState: ContractState = {\n      version: \"hollowdb-vector@^0.1.0\",\n      owner: addr,\n      verificationKeys: { auth: null },\n      isProofRequired: { auth: false },\n      canEvolve: true,\n      whitelists: {\n        put: { [addr]: true },\n        update: { [addr]: true },\n        set: { [addr]: true },\n      },\n      isWhitelistRequired: { put: true, update: true, set: true },\n    };\n\n    const { srcTxId: deploymentSrcTxId, contractTxId } = await warp.deployFromSourceTx({\n      wallet: new ArweaveSigner(wallet),\n      initState: JSON.stringify(initialState),\n      srcTxId: srcTxId,\n      evaluationManifest: {\n        evaluationOptions: {\n          allowBigInt: true,\n          useKVStorage: true,\n        },\n      },\n    });\n\n    // impossible case, but still we should check for it\n    if (deploymentSrcTxId !== srcTxId) {\n      console.error(\"Deployed srcTxId is different than the given source!\");\n      console.error({ expected: srcTxId, received: deploymentSrcTxId });\n    }\n\n    return { contractTxId, srcTxId };\n  }\n}\n","import { NodeHeap, compareNode, cosine_distance } from \"./utils\";\nimport type { Point, Node, LayerNode, KNNResult } from \"./types\";\nimport type { DBInterface } from \"./db/interfaces\";\n\n/**\n * An implementation of Hierarchical Navigable Small Worlds\n * that works over a key-value database.\n *\n * In particular, we provide a HollowDB interface that allows you to\n * store data on Arweave.\n *\n * @template M type of the metadata, which is extra information\n * stored along with each point, a common practice in vectorDBs.\n */\nexport class HNSW<M = unknown> {\n  /** A database that supports `DBInterface`. */\n  db: DBInterface<M>;\n\n  /** Number of established connections; should increase as dimension size increases. */\n  m: number;\n  /** Maximum number of connections for each element per layer. */\n  m_max0: number;\n  /** Normalization factor for level generation. */\n  ml: number;\n\n  /** Size of the dynamic candidate list. Affects build times, 400 is very powerful, 40 is fast. */\n  ef_construction: number;\n  /** Factor for quality of search. */\n  ef: number;\n\n  constructor(db: DBInterface<M>, M: number, ef_construction: number, ef_search: number) {\n    this.db = db;\n\n    this.m = M; // paper proposes [5,48] is a good range for m (Weavite uses 64)\n    this.m_max0 = M * 2; // paper proposes max0 is 2 times m\n    this.ml = 1 / Math.log(M); // papers heuristic to select ml, maximum layers\n\n    this.ef_construction = ef_construction;\n    this.ef = ef_search;\n  }\n\n  /** Returns the vector & its metadata at given index. */\n  async get_vector(idx: number): Promise<{\n    point: Point;\n    metadata: M | null;\n  }> {\n    const point = await this.db.get_point(idx);\n    const metadata = await this.db.get_metadata(idx);\n    return { point, metadata };\n  }\n\n  /** Paper proposes this heuristic for layer selection for insertion of `q`. */\n  select_layer() {\n    return Math.floor(-Math.log(Math.random()) * this.ml);\n  }\n\n  /** Insert a query point.\n   * @see https://arxiv.org/pdf/1603.09320.pdf Algorithm 1\n   */\n  async insert(q: Point, metadata?: M) {\n    const ep_index = await this.db.get_ep();\n    const L = (await this.db.get_num_layers()) - 1;\n    const l = this.select_layer();\n\n    // a point is added and we get its index\n    const idx = await this.db.new_point(q);\n    if (metadata) {\n      await this.db.set_metadata(idx, metadata);\n    }\n\n    if (ep_index !== null) {\n      const dist = cosine_distance(q, await this.db.get_point(ep_index));\n      // iterate for each layer from L to l+1 and find entry point\n      let ep = [[dist, ep_index] as Node];\n      for (let i = L; i > l; i--) {\n        const ep_copy: Node[] = ep.map((e) => [e[0], e[1]]);\n\n        // search with ef = 1, returning only one neighbor\n        const W = await this.search_layer(q, ep_copy, 1, i);\n\n        // if nearest neighbor found in layer i is closer than ep, then ep = nearest neighbor\n        if (W.length > 0 && ep[0][0] > W[0][0]) {\n          ep = W;\n        }\n      }\n\n      // search all layers\n      for (let l_c = Math.min(L, l); l_c >= 0; l_c--) {\n        const W = await this.search_layer(q, ep, this.ef_construction, l_c);\n        const newNode: LayerNode = {}; // this is for `this.graphs[l_c][idx] = {}`\n\n        ep = W.map((e) => [e[0], e[1]] as Node); // copy W to ep\n        const neighbors = this.select_neighbors(q, W, l_c);\n        const indices = neighbors.map(([, idx]) => idx);\n        const nodes = await this.db.get_neighbors(l_c, indices);\n\n        // add bidirectional connections from neighbors to q at layer l_c\n        const M = l_c === 0 ? this.m_max0 : this.m;\n\n        for (const e of neighbors) {\n          newNode[e[1]] = e[0];\n          nodes[e[1]][idx] = e[0];\n        }\n\n        for (const e of neighbors) {\n          const eConn = Object.entries(nodes[e[1]]).map(([k, v]) => [v, parseInt(k)] as Node);\n          if (eConn.length > M) {\n            // shrink connections\n            const eNewConn = this.select_neighbors(await this.db.get_point(e[1]), eConn, l_c);\n            // loop below equivalent to: self.graphs[l_c][e[1]] = {ind: dist for dist, ind in eNewConn}\n            const dict: Record<number, number> = {};\n            for (const eNew of eNewConn) {\n              dict[eNew[1]] = eNew[0];\n            }\n\n            nodes[e[1]] = dict; // equiv: this.graphs[l_c][e[1]] = dict;\n          }\n        }\n\n        await this.db.upsert_neighbor(l_c, idx, newNode);\n        await this.db.upsert_neighbors(l_c, nodes);\n      }\n    }\n\n    // add a new small world for each new layer\n    const LL = await this.db.get_num_layers();\n    if (LL < l + 1) {\n      await this.db.set_ep(idx);\n    }\n\n    // TODO: can make this in parallel via a new function that adds N to num_layers\n    for (let i = LL; i < l + 1; i++) {\n      await this.db.new_neighbor(idx);\n    }\n  }\n\n  /** Search a query point.\n   * @see https://arxiv.org/pdf/1603.09320.pdf Algorithm 2\n   */\n  async search_layer(q: Point, ep: Node[], ef: number, l_c: number) {\n    // set of visited elements | v = set(p for _, p in ep)\n    const V = new Set<number>(ep.map(([, id]) => id));\n\n    // set of candidates, min-heapified\n    const C = new NodeHeap(ep);\n\n    // dynamic list of found neighbors, max-heapified | W = [(-mdist, p) for mdist, p in ep]\n    // due to negation of `dist` value, this actually becomes a max-heap\n    const W = new NodeHeap(ep.map(([mdist, p]) => [-mdist, p]));\n\n    while (!C.isEmpty()) {\n      const c = C.pop()!; // extract nearest element from C\n      const c_v: number = c[0]; // get distance of c\n      const f_dist = -W.top(1)[0][0]; // get furthest distance from q, multiply by -1 to make get real distance\n\n      if (c_v > f_dist) {\n        break;\n      }\n\n      // un-visited nodes\n      const neighbors = Object.keys(await this.db.get_neighbor(l_c, c[1]))\n        .map((k) => parseInt(k))\n        .filter((k) => !V.has(k));\n\n      // distances to `q`\n      const points = await this.db.get_points(neighbors);\n      const dists = points.map((p) => cosine_distance(p, q));\n\n      // visit neighbors w.r.t distances\n      dists.forEach((dist, i) => {\n        const e = neighbors[i];\n        V.add(e); // mark `e` as visited\n\n        if (dist < f_dist || W.length < ef) {\n          C.push([dist, e]);\n          W.push([-dist, e]);\n\n          // possible if `dist < f_dist`\n          if (W.length > ef) {\n            W.pop();\n          }\n        }\n      });\n    }\n\n    if (ef === 1) {\n      if (W.length !== 0) {\n        // TODO: is there a faster way to do this code block?\n        const dd = new NodeHeap(W.heapArray.map((W_i) => [-W_i[0], W_i[1]]));\n        return [dd.pop()!];\n      } else {\n        return [];\n      }\n    }\n\n    return W.heapArray.map((W_i) => [-W_i[0], W_i[1]]) as Node[];\n  }\n\n  /** Selects and adds neighbors to the graph.\n   * @see https://arxiv.org/pdf/1603.09320.pdf Algorithm 4\n   */\n  select_neighbors(q: Point, C: Node[], l_c: number, keepPrunedConnections: boolean = true) {\n    const R = new NodeHeap();\n    const W = new NodeHeap(C);\n    const M = l_c > 0 ? this.m : this.m_max0; // number of neighbors to return\n\n    const W_d = new NodeHeap(); // queue for discarded candidates\n    while (W.length > 0 && R.length < M) {\n      const e = W.pop()!; // extract nearest element from W to q\n      const r_top = R.top(1)[0] as Node | undefined; // point with minimum distance to q in all R\n\n      // it is possible that `r_top` is undefined, that is okay & is handled below\n      if (R.length === 0 || (r_top && e[0] < r_top[0])) {\n        R.push([e[0], e[1]]);\n      } else {\n        W_d.push([e[0], e[1]]);\n      }\n    }\n\n    if (keepPrunedConnections) {\n      while (W_d.length > 0 && R.length < M) {\n        R.push(W_d.pop()!);\n      }\n    }\n\n    return R.heapArray;\n  }\n\n  /** K-nearest Neighbor search. */\n  async knn_search(q: Point, K: number): Promise<KNNResult<M>[]> {\n    const ep_index = await this.db.get_ep();\n\n    // edge case: no points were added at all\n    if (ep_index === null) return [];\n\n    const L = (await this.db.get_num_layers()) - 1;\n    const dist = cosine_distance(q, await this.db.get_point(ep_index));\n\n    // search from top layer to layer 1\n    let ep: Node[] = [[dist, ep_index]];\n    for (let l_c = L; l_c > 0; l_c--) {\n      ep = await this.search_layer(q, ep, 1, l_c);\n    }\n    ep = await this.search_layer(q, ep, this.ef, 0);\n\n    // sort the results & get top K\n    ep.sort(compareNode);\n    const ep_topk = ep.slice(0, K);\n\n    // retrieve metadatas\n    const metadatas = await this.db.get_metadatas(ep_topk.map((ep) => ep[1]));\n\n    return ep_topk.map((ep, i) => ({\n      id: ep[1],\n      distance: ep[0],\n      metadata: metadatas[i],\n    }));\n  }\n}\n","import { Heap } from \"heap-js\";\nimport type { Node, Point } from \"../types\";\n\n/** A min-heap of {@link Node} types with custom comparator. */\nexport class NodeHeap extends Heap<Node> {\n  constructor(elems: Node[] = []) {\n    super(compareNode);\n    if (elems.length !== 0) {\n      super.addAll(elems);\n    }\n  }\n}\n\n/** Comparator for {@link Node} type, compares their distances. */\nexport function compareNode(a: Node, b: Node) {\n  return a[0] - b[0];\n}\n\n/** Dot-product of two vectors. */\nexport function dot_product(a: Point, b: Point): number {\n  return a.reduce((sum, val, idx) => sum + val * b[idx], 0);\n}\n\n/** Norm a vector. */\nexport function norm(a: Point): number {\n  return Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n}\n\n/** Cosine distance between two vectors, as 1 - cosine similarity. */\nexport function cosine_distance(a: Point, b: Point): number {\n  return 1 - dot_product(a, b) / (norm(a) * norm(b));\n}\n\n/** Inner product (alias dot product) of two vectors. */\nexport function inner_product(a: Point, b: Point): number {\n  return dot_product(a, b);\n}\n\n/** Euclidean distance between two vectors. */\nexport function l2_distance(a: Point, b: Point): number {\n  return Math.sqrt(a.reduce((sum, val, idx) => sum + Math.pow(val - b[idx], 2), 0));\n}\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","import type { DBInterface } from \"./interfaces\";\nimport type { Graph, LayerNode, Point } from \"../types\";\nimport { decodeLayerNode, decodePoint, encodeLayerNode, encodePoint } from \"../proto\";\nimport { SetSDK } from \"hollowdb\";\nimport { keys, safeParse } from \"./common\";\n\nexport class HollowMemory<M = unknown> implements DBInterface<M> {\n  client: SetSDK<string>;\n\n  /**\n   * Deploy a HollowDB contract.\n   * @param initialState initial state of the contract\n   * @param source (optional) source transaction id\n   * @returns deployed contract transaction id\n   */\n  async deploy(initialState: Awaited<ReturnType<typeof this.client.getState>>, source: string = \"\") {\n    const { contractTxId } = await this.client.warp.deployFromSourceTx({\n      wallet: this.client.signer,\n      srcTxId: source,\n      initState: JSON.stringify(initialState),\n    });\n\n    return contractTxId;\n  }\n\n  constructor(client: SetSDK<string>) {\n    this.client = client;\n  }\n\n  async get_ep(): Promise<number | null> {\n    const ep = await this.client.get(keys.ep);\n    return ep === null ? null : parseInt(ep);\n  }\n\n  async set_ep(ep: number): Promise<void> {\n    await this.client.set(keys.ep, ep.toString());\n  }\n\n  async get_point(idx: number): Promise<Point> {\n    const data = await this.client.get(keys.point(idx));\n    if (!data) {\n      throw new Error(`No point with index ${idx}`);\n    }\n    const point = decodePoint(data);\n    return point.v!;\n  }\n\n  async get_points(idxs: number[]): Promise<Point[]> {\n    if (idxs.length === 0) return [];\n    const datas = await this.safe_get_many(idxs.map((idx) => keys.point(idx)));\n\n    // see if there is a null value in there\n    const nullPos = datas.indexOf(null);\n    if (nullPos !== -1) {\n      throw new Error(`No point with index ${idxs[nullPos]}`);\n    }\n\n    const points = datas.map((data) => decodePoint(data!));\n    return points.map((point) => point.v!);\n  }\n\n  async new_point(q: Point): Promise<number> {\n    const idx = await this.get_datasize();\n\n    const point = encodePoint({ v: q, idx });\n    await this.client.set(keys.point(idx), point);\n    await this.client.set(keys.points, (idx + 1).toString());\n\n    return idx;\n  }\n\n  async get_num_layers(): Promise<number> {\n    const numLayers = await this.client.get(keys.layers);\n    return numLayers ? parseInt(numLayers) : 0;\n  }\n\n  async get_datasize(): Promise<number> {\n    const datasize = await this.client.get(keys.points);\n    return datasize ? parseInt(datasize) : 0;\n  }\n\n  async get_neighbor(layer: number, idx: number): Promise<LayerNode> {\n    const data = await this.client.get(keys.neighbor(layer, idx));\n    if (!data) {\n      throw new Error(`No neighbors at layer ${layer}, index ${idx}\"`);\n    }\n    const node = decodeLayerNode(data);\n    return node.neighbors!;\n  }\n\n  async get_neighbors(layer: number, idxs: number[]): Promise<Graph> {\n    const datas = await this.safe_get_many(idxs.map((idx) => keys.neighbor(layer, idx)));\n\n    // see if there is a null value in there\n    const nullPos = datas.indexOf(null);\n    if (nullPos !== -1) {\n      throw new Error(`No neighbors at layer ${layer}, index ${idxs[nullPos]}\"`);\n    }\n\n    const nodes = datas.map((data) => decodeLayerNode(data!));\n    const neighbors = nodes.map((node) => node.neighbors!);\n    return Object.fromEntries(idxs.map((idx, i) => [idx, neighbors[i]]));\n  }\n\n  async upsert_neighbor(layer: number, idx: number, node: LayerNode): Promise<void> {\n    const data = encodeLayerNode({\n      idx,\n      level: layer,\n      neighbors: node,\n    });\n    await this.client.set(keys.neighbor(layer, idx), data);\n  }\n\n  async upsert_neighbors(layer: number, nodes: Graph): Promise<void> {\n    await this.safe_set_many(\n      Object.keys(nodes).map((idx) => {\n        const i = parseInt(idx);\n        const key = keys.neighbor(layer, i);\n        const value = encodeLayerNode({\n          idx: i,\n          level: layer,\n          neighbors: nodes[i],\n        });\n\n        return [key, value];\n      }),\n    );\n  }\n\n  async new_neighbor(idx: number): Promise<void> {\n    const l = await this.get_num_layers();\n    await this.upsert_neighbor(l, idx, {});\n\n    // NOTE: if `new_neighbor` is run in parallel,\n    // this might cause a race-condition\n    await this.client.set(keys.layers, (l + 1).toString());\n  }\n\n  async get_metadata(idx: number): Promise<M | null> {\n    const data = await this.client.get(keys.metadata(idx));\n    return safeParse<M>(data);\n  }\n\n  async get_metadatas(idxs: number[]): Promise<(M | null)[]> {\n    // const datas =\n    return Promise.all(idxs.map((idx) => this.get_metadata(idx)));\n  }\n\n  async set_metadata(idx: number, data: M): Promise<void> {\n    await this.client.set(keys.metadata(idx), JSON.stringify(data));\n  }\n\n  /**\n   * A `getMany` interaction that automatically splits the request into several\n   * transactions so that the transaction body-limit is not exceeded for any of them.\n   *\n   * For every error, the input is split into two transactions of half the size.\n   */\n  private async safe_get_many(keys: string[]): Promise<(string | null)[]> {\n    try {\n      return await this.client.getMany(keys);\n    } catch (err) {\n      // TODO: check error type\n      const half = Math.floor(keys.length >> 1);\n\n      // prettier-ignore\n      return await Promise.all([\n        this.safe_get_many(keys.slice(0, half)),\n        this.safe_get_many(keys.slice(half))]\n      ).then((results) => results.flat());\n    }\n  }\n\n  /**\n   * A `setMany` interaction that automatically splits the request into several\n   * transactions so that the transaction body-limit is not exceeded for any of them.\n   *\n   * For every error, the input is split into two transactions of half the size.\n   */\n  private async safe_set_many(entries: [key: string, value: string][]): Promise<void> {\n    try {\n      await this.client.setMany(\n        entries.map((e) => e[0]),\n        entries.map((e) => e[1]),\n      );\n    } catch (err) {\n      // TODO: check error type\n      const half = Math.floor(entries.length >> 1);\n\n      // prettier-ignore\n      await Promise.all([\n        this.safe_set_many(entries.slice(0, half)),\n        this.safe_set_many(entries.slice(half))]\n      ).then((results) => results.flat());\n    }\n  }\n\n  toString() {\n    return \"HollowDB Set with Protobufs\";\n  }\n}\n","import { index_buffer } from \"../../proto/hnsw_comm\";\n\n/** Encodes a point to protobuf & base64's it. */\nexport function encodePoint(q: index_buffer.IPoint): string {\n  const qe = index_buffer.Point.encode(q).finish();\n  return Buffer.from(qe).toString(\"base64\");\n}\n\n/** Decodes a point from base64 encoded protobuf. */\nexport function decodePoint(data: string): index_buffer.IPoint {\n  const dec = Buffer.from(data, \"base64\");\n  return index_buffer.Point.decode(dec);\n}\n\n/** Encodes a point to protobuf & base64's it. */\nexport function encodeLayerNode(n: index_buffer.ILayerNode): string {\n  const ne = index_buffer.LayerNode.encode({\n    ...n,\n    visible: n.visible || true, // is visible unless otherwise specified\n  }).finish();\n  return Buffer.from(ne).toString(\"base64\");\n}\n\n/** Decodes a point from base64 encoded protobuf. */\nexport function decodeLayerNode(data: string): index_buffer.ILayerNode {\n  const dec = Buffer.from(data, \"base64\");\n  return index_buffer.LayerNode.decode(dec);\n}\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.index_buffer = (function() {\n\n    /**\n     * Namespace index_buffer.\n     * @exports index_buffer\n     * @namespace\n     */\n    var index_buffer = {};\n\n    index_buffer.LayerNode = (function() {\n\n        /**\n         * Properties of a LayerNode.\n         * @memberof index_buffer\n         * @interface ILayerNode\n         * @property {number|null} [level] LayerNode level\n         * @property {number|null} [idx] LayerNode idx\n         * @property {boolean|null} [visible] LayerNode visible\n         * @property {Object.<string,number>|null} [neighbors] LayerNode neighbors\n         */\n\n        /**\n         * Constructs a new LayerNode.\n         * @memberof index_buffer\n         * @classdesc Represents a LayerNode.\n         * @implements ILayerNode\n         * @constructor\n         * @param {index_buffer.ILayerNode=} [properties] Properties to set\n         */\n        function LayerNode(properties) {\n            this.neighbors = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LayerNode level.\n         * @member {number} level\n         * @memberof index_buffer.LayerNode\n         * @instance\n         */\n        LayerNode.prototype.level = 0;\n\n        /**\n         * LayerNode idx.\n         * @member {number} idx\n         * @memberof index_buffer.LayerNode\n         * @instance\n         */\n        LayerNode.prototype.idx = 0;\n\n        /**\n         * LayerNode visible.\n         * @member {boolean} visible\n         * @memberof index_buffer.LayerNode\n         * @instance\n         */\n        LayerNode.prototype.visible = false;\n\n        /**\n         * LayerNode neighbors.\n         * @member {Object.<string,number>} neighbors\n         * @memberof index_buffer.LayerNode\n         * @instance\n         */\n        LayerNode.prototype.neighbors = $util.emptyObject;\n\n        /**\n         * Creates a new LayerNode instance using the specified properties.\n         * @function create\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {index_buffer.ILayerNode=} [properties] Properties to set\n         * @returns {index_buffer.LayerNode} LayerNode instance\n         */\n        LayerNode.create = function create(properties) {\n            return new LayerNode(properties);\n        };\n\n        /**\n         * Encodes the specified LayerNode message. Does not implicitly {@link index_buffer.LayerNode.verify|verify} messages.\n         * @function encode\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {index_buffer.ILayerNode} message LayerNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LayerNode.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.level != null && Object.hasOwnProperty.call(message, \"level\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.level);\n            if (message.idx != null && Object.hasOwnProperty.call(message, \"idx\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.idx);\n            if (message.visible != null && Object.hasOwnProperty.call(message, \"visible\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.visible);\n            if (message.neighbors != null && Object.hasOwnProperty.call(message, \"neighbors\"))\n                for (var keys = Object.keys(message.neighbors), i = 0; i < keys.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 5 =*/21).float(message.neighbors[keys[i]]).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LayerNode message, length delimited. Does not implicitly {@link index_buffer.LayerNode.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {index_buffer.ILayerNode} message LayerNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LayerNode.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LayerNode message from the specified reader or buffer.\n         * @function decode\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {index_buffer.LayerNode} LayerNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LayerNode.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.index_buffer.LayerNode(), key, value;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.level = reader.uint32();\n                        break;\n                    }\n                case 2: {\n                        message.idx = reader.uint32();\n                        break;\n                    }\n                case 3: {\n                        message.visible = reader.bool();\n                        break;\n                    }\n                case 4: {\n                        if (message.neighbors === $util.emptyObject)\n                            message.neighbors = {};\n                        var end2 = reader.uint32() + reader.pos;\n                        key = 0;\n                        value = 0;\n                        while (reader.pos < end2) {\n                            var tag2 = reader.uint32();\n                            switch (tag2 >>> 3) {\n                            case 1:\n                                key = reader.uint32();\n                                break;\n                            case 2:\n                                value = reader.float();\n                                break;\n                            default:\n                                reader.skipType(tag2 & 7);\n                                break;\n                            }\n                        }\n                        message.neighbors[key] = value;\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LayerNode message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {index_buffer.LayerNode} LayerNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LayerNode.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LayerNode message.\n         * @function verify\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LayerNode.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.level != null && message.hasOwnProperty(\"level\"))\n                if (!$util.isInteger(message.level))\n                    return \"level: integer expected\";\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                if (!$util.isInteger(message.idx))\n                    return \"idx: integer expected\";\n            if (message.visible != null && message.hasOwnProperty(\"visible\"))\n                if (typeof message.visible !== \"boolean\")\n                    return \"visible: boolean expected\";\n            if (message.neighbors != null && message.hasOwnProperty(\"neighbors\")) {\n                if (!$util.isObject(message.neighbors))\n                    return \"neighbors: object expected\";\n                var key = Object.keys(message.neighbors);\n                for (var i = 0; i < key.length; ++i) {\n                    if (!$util.key32Re.test(key[i]))\n                        return \"neighbors: integer key{k:uint32} expected\";\n                    if (typeof message.neighbors[key[i]] !== \"number\")\n                        return \"neighbors: number{k:uint32} expected\";\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a LayerNode message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {index_buffer.LayerNode} LayerNode\n         */\n        LayerNode.fromObject = function fromObject(object) {\n            if (object instanceof $root.index_buffer.LayerNode)\n                return object;\n            var message = new $root.index_buffer.LayerNode();\n            if (object.level != null)\n                message.level = object.level >>> 0;\n            if (object.idx != null)\n                message.idx = object.idx >>> 0;\n            if (object.visible != null)\n                message.visible = Boolean(object.visible);\n            if (object.neighbors) {\n                if (typeof object.neighbors !== \"object\")\n                    throw TypeError(\".index_buffer.LayerNode.neighbors: object expected\");\n                message.neighbors = {};\n                for (var keys = Object.keys(object.neighbors), i = 0; i < keys.length; ++i)\n                    message.neighbors[keys[i]] = Number(object.neighbors[keys[i]]);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LayerNode message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {index_buffer.LayerNode} message LayerNode\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LayerNode.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n                object.neighbors = {};\n            if (options.defaults) {\n                object.level = 0;\n                object.idx = 0;\n                object.visible = false;\n            }\n            if (message.level != null && message.hasOwnProperty(\"level\"))\n                object.level = message.level;\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                object.idx = message.idx;\n            if (message.visible != null && message.hasOwnProperty(\"visible\"))\n                object.visible = message.visible;\n            var keys2;\n            if (message.neighbors && (keys2 = Object.keys(message.neighbors)).length) {\n                object.neighbors = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.neighbors[keys2[j]] = options.json && !isFinite(message.neighbors[keys2[j]]) ? String(message.neighbors[keys2[j]]) : message.neighbors[keys2[j]];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this LayerNode to JSON.\n         * @function toJSON\n         * @memberof index_buffer.LayerNode\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LayerNode.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for LayerNode\n         * @function getTypeUrl\n         * @memberof index_buffer.LayerNode\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        LayerNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/index_buffer.LayerNode\";\n        };\n\n        return LayerNode;\n    })();\n\n    index_buffer.Point = (function() {\n\n        /**\n         * Properties of a Point.\n         * @memberof index_buffer\n         * @interface IPoint\n         * @property {number|null} [idx] Point idx\n         * @property {Array.<number>|null} [v] Point v\n         */\n\n        /**\n         * Constructs a new Point.\n         * @memberof index_buffer\n         * @classdesc Represents a Point.\n         * @implements IPoint\n         * @constructor\n         * @param {index_buffer.IPoint=} [properties] Properties to set\n         */\n        function Point(properties) {\n            this.v = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Point idx.\n         * @member {number} idx\n         * @memberof index_buffer.Point\n         * @instance\n         */\n        Point.prototype.idx = 0;\n\n        /**\n         * Point v.\n         * @member {Array.<number>} v\n         * @memberof index_buffer.Point\n         * @instance\n         */\n        Point.prototype.v = $util.emptyArray;\n\n        /**\n         * Creates a new Point instance using the specified properties.\n         * @function create\n         * @memberof index_buffer.Point\n         * @static\n         * @param {index_buffer.IPoint=} [properties] Properties to set\n         * @returns {index_buffer.Point} Point instance\n         */\n        Point.create = function create(properties) {\n            return new Point(properties);\n        };\n\n        /**\n         * Encodes the specified Point message. Does not implicitly {@link index_buffer.Point.verify|verify} messages.\n         * @function encode\n         * @memberof index_buffer.Point\n         * @static\n         * @param {index_buffer.IPoint} message Point message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Point.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.idx != null && Object.hasOwnProperty.call(message, \"idx\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idx);\n            if (message.v != null && message.v.length) {\n                writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                for (var i = 0; i < message.v.length; ++i)\n                    writer.float(message.v[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Point message, length delimited. Does not implicitly {@link index_buffer.Point.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof index_buffer.Point\n         * @static\n         * @param {index_buffer.IPoint} message Point message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Point.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Point message from the specified reader or buffer.\n         * @function decode\n         * @memberof index_buffer.Point\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {index_buffer.Point} Point\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Point.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.index_buffer.Point();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.idx = reader.uint32();\n                        break;\n                    }\n                case 2: {\n                        if (!(message.v && message.v.length))\n                            message.v = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.v.push(reader.float());\n                        } else\n                            message.v.push(reader.float());\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Point message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof index_buffer.Point\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {index_buffer.Point} Point\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Point.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Point message.\n         * @function verify\n         * @memberof index_buffer.Point\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Point.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                if (!$util.isInteger(message.idx))\n                    return \"idx: integer expected\";\n            if (message.v != null && message.hasOwnProperty(\"v\")) {\n                if (!Array.isArray(message.v))\n                    return \"v: array expected\";\n                for (var i = 0; i < message.v.length; ++i)\n                    if (typeof message.v[i] !== \"number\")\n                        return \"v: number[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Point message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof index_buffer.Point\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {index_buffer.Point} Point\n         */\n        Point.fromObject = function fromObject(object) {\n            if (object instanceof $root.index_buffer.Point)\n                return object;\n            var message = new $root.index_buffer.Point();\n            if (object.idx != null)\n                message.idx = object.idx >>> 0;\n            if (object.v) {\n                if (!Array.isArray(object.v))\n                    throw TypeError(\".index_buffer.Point.v: array expected\");\n                message.v = [];\n                for (var i = 0; i < object.v.length; ++i)\n                    message.v[i] = Number(object.v[i]);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Point message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof index_buffer.Point\n         * @static\n         * @param {index_buffer.Point} message Point\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Point.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.v = [];\n            if (options.defaults)\n                object.idx = 0;\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                object.idx = message.idx;\n            if (message.v && message.v.length) {\n                object.v = [];\n                for (var j = 0; j < message.v.length; ++j)\n                    object.v[j] = options.json && !isFinite(message.v[j]) ? String(message.v[j]) : message.v[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this Point to JSON.\n         * @function toJSON\n         * @memberof index_buffer.Point\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Point.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for Point\n         * @function getTypeUrl\n         * @memberof index_buffer.Point\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/index_buffer.Point\";\n        };\n\n        return Point;\n    })();\n\n    index_buffer.PointQuant = (function() {\n\n        /**\n         * Properties of a PointQuant.\n         * @memberof index_buffer\n         * @interface IPointQuant\n         * @property {number|null} [idx] PointQuant idx\n         * @property {Array.<number>|null} [v] PointQuant v\n         */\n\n        /**\n         * Constructs a new PointQuant.\n         * @memberof index_buffer\n         * @classdesc Represents a PointQuant.\n         * @implements IPointQuant\n         * @constructor\n         * @param {index_buffer.IPointQuant=} [properties] Properties to set\n         */\n        function PointQuant(properties) {\n            this.v = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * PointQuant idx.\n         * @member {number} idx\n         * @memberof index_buffer.PointQuant\n         * @instance\n         */\n        PointQuant.prototype.idx = 0;\n\n        /**\n         * PointQuant v.\n         * @member {Array.<number>} v\n         * @memberof index_buffer.PointQuant\n         * @instance\n         */\n        PointQuant.prototype.v = $util.emptyArray;\n\n        /**\n         * Creates a new PointQuant instance using the specified properties.\n         * @function create\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {index_buffer.IPointQuant=} [properties] Properties to set\n         * @returns {index_buffer.PointQuant} PointQuant instance\n         */\n        PointQuant.create = function create(properties) {\n            return new PointQuant(properties);\n        };\n\n        /**\n         * Encodes the specified PointQuant message. Does not implicitly {@link index_buffer.PointQuant.verify|verify} messages.\n         * @function encode\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {index_buffer.IPointQuant} message PointQuant message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PointQuant.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.idx != null && Object.hasOwnProperty.call(message, \"idx\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idx);\n            if (message.v != null && message.v.length) {\n                writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                for (var i = 0; i < message.v.length; ++i)\n                    writer.uint32(message.v[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified PointQuant message, length delimited. Does not implicitly {@link index_buffer.PointQuant.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {index_buffer.IPointQuant} message PointQuant message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PointQuant.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a PointQuant message from the specified reader or buffer.\n         * @function decode\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {index_buffer.PointQuant} PointQuant\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PointQuant.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.index_buffer.PointQuant();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.idx = reader.uint32();\n                        break;\n                    }\n                case 2: {\n                        if (!(message.v && message.v.length))\n                            message.v = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.v.push(reader.uint32());\n                        } else\n                            message.v.push(reader.uint32());\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a PointQuant message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {index_buffer.PointQuant} PointQuant\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PointQuant.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a PointQuant message.\n         * @function verify\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        PointQuant.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                if (!$util.isInteger(message.idx))\n                    return \"idx: integer expected\";\n            if (message.v != null && message.hasOwnProperty(\"v\")) {\n                if (!Array.isArray(message.v))\n                    return \"v: array expected\";\n                for (var i = 0; i < message.v.length; ++i)\n                    if (!$util.isInteger(message.v[i]))\n                        return \"v: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a PointQuant message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {index_buffer.PointQuant} PointQuant\n         */\n        PointQuant.fromObject = function fromObject(object) {\n            if (object instanceof $root.index_buffer.PointQuant)\n                return object;\n            var message = new $root.index_buffer.PointQuant();\n            if (object.idx != null)\n                message.idx = object.idx >>> 0;\n            if (object.v) {\n                if (!Array.isArray(object.v))\n                    throw TypeError(\".index_buffer.PointQuant.v: array expected\");\n                message.v = [];\n                for (var i = 0; i < object.v.length; ++i)\n                    message.v[i] = object.v[i] >>> 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a PointQuant message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {index_buffer.PointQuant} message PointQuant\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        PointQuant.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.v = [];\n            if (options.defaults)\n                object.idx = 0;\n            if (message.idx != null && message.hasOwnProperty(\"idx\"))\n                object.idx = message.idx;\n            if (message.v && message.v.length) {\n                object.v = [];\n                for (var j = 0; j < message.v.length; ++j)\n                    object.v[j] = message.v[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this PointQuant to JSON.\n         * @function toJSON\n         * @memberof index_buffer.PointQuant\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        PointQuant.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for PointQuant\n         * @function getTypeUrl\n         * @memberof index_buffer.PointQuant\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        PointQuant.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/index_buffer.PointQuant\";\n        };\n\n        return PointQuant;\n    })();\n\n    return index_buffer;\n})();\n\nmodule.exports = $root;\n","/** Utilities to get the key in KVdb for a value. */\nexport const keys = {\n  layers: \"layers\",\n  ep: \"ep\",\n  points: \"points\",\n  metadata: (idx: number) => `m:${idx}` as const,\n  /** Maps a point index to its key in the KVdb. */\n  point: (idx: number) => `${idx}` as const,\n  /** Maps a neighbor (layer & index) to its key in the KVdb. */\n  neighbor: (layer: number, idx: number) => `${layer}__${idx}` as const,\n} as const;\n\n/** Safely parses a data, returning `null` if its falsy. */\nexport function safeParse<V = unknown>(data: string | null | undefined): V | null {\n  return data ? JSON.parse(data) : null;\n}\n"],"names":[],"version":3,"file":"index.mjs.map","sourceRoot":"../"}